/*@@
 * @file    %{file}
 * @date    %{date}
 * @author  Marek Blazewicz
 * @desc
 * The prototype of the CaCUDA computational schema. It contains macros
 * which enable to declare, define and launch kernels as well as to copy
 * the data required for proper computations. The macros presented
 * in this file in the future will be automatically generated by the
 * Cactus parser depending on the input in interfaces.ccl file.
 * @enddesc
 * @version  $Header$
 *
 @@*/

#ifndef %{name_upper}
#define %{name_upper}

#include <algorithm>

/* definition of CCTK_REAL */
#include "cctk.h"

/* CaCUDAUtil.h shall be visible to all CaCUDA developers at some point */
#include "CaCUDA/CaCUDALib/src/CaCUDAUtil.h"

#include "cctk_Parameters.h"
#include "cctk_Arguments.h"

#ifdef __CUDACC__

/// !!!!!!!!!!!!! BEGIN of global definitions (not auto generated) !!!!!!!!!!!!!!!!

#define CAKERNEL_Threadsx %{tile_x}
#define CAKERNEL_Threadsy %{tile_y}
#define CAKERNEL_Threadsz 1

/* JT: 16x16x16 failed to compile on spider. 8x8x8 is ok to compile.
 * Let's make 8x8x8 as the default setting temporarily.
 * We will need to estimate the best configuration based on
 * the number of variables and the memory available.
 * */
#define CAKERNEL_Tilex %{tile_x}
#define CAKERNEL_Tiley %{tile_y}
#define CAKERNEL_Tilez %{tile_z}


/// !!!!!!!!!!!!! END of global definitions (not auto generated) !!!!!!!!!!!!!!!!

/// !!!!!!!!!!!!!!!!!!!!!!!!! BEGIN %{name} Kernel macors !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifdef stncl_xn
#error "You can't include two header file in one execution file"
#endif

#define stncl_xn %{stencil_xn}
#define stncl_xp %{stencil_xp}
#define stncl_yn %{stencil_yn}
#define stncl_yp %{stencil_yp}
#define stncl_zn %{stencil_zn}
#define stncl_zp %{stencil_zp}
                 
/** Element  */
#define CAKERNEL_GFINDEX3D_%{name}(ptr, i, j, k)               \
 ptr[(i + gi) + params.cagh_ni * ((j + gj) + params.cagh_nj * (k + gk))]

// indexing function; havn't been tested yet
template<int i, int j, int k, typename t>
__device__ inline CCTK_REAL & cctk_cuda_gfindex3d_%{name}_lhelper
         (t ptr_sh, const short & li, const short & lj, const short & lk
           %for_loop(tmpi,'1','%{stencil_zp}+1',',CCTK_REAL & v_p%var(tmpi)')
           %for_loop(tmpi,'1','%{stencil_zn}+1',',CCTK_REAL & v_n%var(tmpi)')
         )
{
    if(k == 0) return ptr_sh[j + lj][i + li];
    %for_loop(i,'1','%{stencil_zp}+1','if(k == %var(i)) return v_p%var(i);')
    %for_loop(i,'1','%{stencil_zn}+1','if(k ==-%var(i)) return v_n%var(i);')
}

// Static derefernce of the variables 
#define CAKERNEL_GFINDEX3D_%{name}_l(ptr, i, j, k)                     \
    cctk_cuda_gfindex3d_%{name}_lhelper<i, j, k>(ptr##_sh, li, lj, lk       \
  %for_loop(tmpi,'1','%{stencil_zp}+1',', ptr##_p%var(tmpi)')               \
  %for_loop(tmpi,'1','%{stencil_zn}+1',', ptr##_n%var(tmpi)')               \
    )

// Dynamic derefernce of the variables (necessary to use this macro )
#  define CAKERNEL_GFINDEX3D_%{name}_ld(ptr, i, j, k)                  \
    ((k == 0) ? ptr##_sh[j + lj][i + li] : (k > 0) ?                        \
    ptr##_v[k + lk - 1] : ptr##_v[k + lk])

#  define CAKERNEL_GFINDEX3D_%{name}_l2(ptr, i, j, k)                  \
    ((k == 0) ? ptr##_sh[j + lj][i + li] : (k == 1) ?                        \
    ptr##_p1 : ptr##_n1)

#define I3D CAKERNEL_GFINDEX3D_%{name}
#define I3D_l CAKERNEL_GFINDEX3D_%{name}_l
#define I3D_ld CAKERNEL_GFINDEX3D_%{name}_ld

#define CAKERNEL_%{name}_Declare_Begin_s                               \
__global__ void CAKERNEL_%{name}(                                      \
/** Variables automatically added by the Cactus parser:  */                 \
%var_loop("intent=separateinout",'const CCTK_REAL *%{vname}, CCTK_REAL *%{vname}_out,')\
%var_loop("intent=inout", 'CCTK_REAL *%{vname},')\
%var_loop("intent=in", 'const CCTK_REAL *%{vname},')\
%var_loop("intent=out", 'CCTK_REAL *%{vname}_out,')\
/** Statically added variables to each kernel: */                           \
const CaCUDA_Kernel_Launch_Parameters params)                               \
{                                                                           
# define CAKERNEL_%{name}_Declare_Cached_Variables_s                   \
/** Kernel specific variables declaration. */                               \
  %var_loop("cached=yes",'__shared__ CCTK_REAL %{vname}_sh[CAKERNEL_Tiley][CAKERNEL_Tilex];')\
  %for_loop(tmpi,'1','%{stencil_zp}+1','CCTK_REAL %var_loop("cached=yes","delimit=, ","%{vname}_p%var(tmpi)");')\
  %for_loop(tmpi,'1','%{stencil_zn}+1','CCTK_REAL %var_loop("cached=yes","delimit=, ","%{vname}_n%var(tmpi)");')\
//%var_loop("cached=yes",'CCTK_REAL %{vname}_v[stncl_zn + stncl_zp];')      \
/** Common variables declaration; values are kernel specific. */            
# define CAKERNEL_%{name}_Declare_Flow_Variables_s                     \
  short li = threadIdx.x;                                                   \
  short lj = threadIdx.y;                                                   \
  short lk = threadIdx.z + stncl_zn;                                        \
  int gi = blockIdx.x * (CAKERNEL_Tilex - stncl_xn - stncl_xp) + li;   \
  int gj = (blockIdx.y % params.cagh_blocky) *                              \
          (CAKERNEL_Tiley - stncl_yn - stncl_yp) + lj;                 \
  int gk2= (blockIdx.y / params.cagh_blocky) *                              \
          (CAKERNEL_Tilez - stncl_zn - stncl_zp) + lk;                 \
  int gk = gk2;                                                             \
  bool fetch_data = gi < params.cagh_ni && gj < params.cagh_nj;             \
  bool compute = gi < params.cagh_ni - 1 && gj < params.cagh_nj - 1 &&      \
    li >= stncl_xn && lj >= stncl_yn &&                                     \
    li < CAKERNEL_Tilex - stncl_xp &&                                  \
    lj < CAKERNEL_Tiley - stncl_yp;                                    \
  short tilez_to = min(CAKERNEL_Tilez - stncl_zp - stncl_zn,           \
                        params.cagh_nk - gk - stncl_zp);                    \
  short tmpj;                                                               \
    /** Dynamically set fetching from global memory */                      
# define CAKERNEL_%{name}_Limit_Threads_To_LSH_Begin_s                 \
  if(fetch_data)                                                            \
  {                                                                         
#   define CAKERNEL_%{name}_Fetch_Data_To_Cache_s                      \
%for_loop(tmpi,'-%{stencil_zn}','%{stencil_zp}') %[                         \
      %var_loop("cached=yes") %[                                            \
    I3D_l(%vname, 0, 0, %var(tmpi) + 1) = I3D(%vname, 0, 0, %var(tmpi));]%]%\
                                                                            \
//    The loop is suppose to fetch the data from global to cached memory.   \
//    For cached variables only!                                            \
//    for (tmpi = -stncl_zn; tmpi < stncl_zp; tmpi++)                       \
//    {                                                                     \
//      I3D_l(vx, 0, 0, tmpi + 1) = I3D(vx, 0, 0, tmpi);                    \
//      I3D_l(vy, 0, 0, tmpi + 1) = I3D(vy, 0, 0, tmpi);                    \
//      I3D_l(vz, 0, 0, tmpi + 1) = I3D(vz, 0, 0, tmpi);                    \
//      I3D_l(p,  0, 0, tmpi + 1) = I3D(p,  0, 0, tmpi);                    \
//    }

#   define CAKERNEL_%{name}_Computations_Begin_s                       \
    for(tmpj = 0; tmpj < tilez_to; tmpj++)                                  \
    {                                                                       \
      __syncthreads();                                                      
#     define CAKERNEL_%{name}_Iterate_Local_Tile_s                     \
%for_loop(tmpi,'-%{stencil_zn}','%{stencil_zp}') %[                         \
      %var_loop("cached=yes") %[                                            \
  I3D_l(%vname, 0, 0, %var(tmpi)) = I3D_l(%vname, 0, 0, %var(tmpi) + 1);]%]%\
                                                                            \
      gk = gk2 + tmpj;                                                      
//    The loop is suppose to iterate local variables, as the tiles 'walks'  \
      through the z dimension. For cached variables only!                   \
      for (tmpi = -stncl_zn; tmpi < stncl_zp; tmpi++)                       \
      {                                                                     \
        I3D_l(vx, 0, 0, tmpi) = I3D_l(vx, 0, 0, tmpi + 1);                  \
        I3D_l(vy, 0, 0, tmpi) = I3D_l(vy, 0, 0, tmpi + 1);                  \
        I3D_l(vz, 0, 0, tmpi) = I3D_l(vz, 0, 0, tmpi + 1);                  \
      }                                                                   
#     define CAKERNEL_%{name}_Fetch_Front_Tile_To_Cache_s              \
      %var_loop("cached=yes") %[                                            \
        I3D_l(%vname, 0, 0, stncl_zp) = I3D(%vname, 0, 0, stncl_zp);]%      \
                                                                            \
      __syncthreads();                                                      
//      I3D_l(vx, 0, 0, stncl_zp) = I3D(vx, 0, 0, stncl_zp);                \
//      I3D_l(vy, 0, 0, stncl_zp) = I3D(vy, 0, 0, stncl_zp);                \
//      I3D_l(vz, 0, 0, stncl_zp) = I3D(vz, 0, 0, stncl_zp);                
#     define CAKERNEL_%{name}_Limit_Threads_To_Compute_Begin_s         \
      if(compute)                                                           \
      {                                                                     \
      /*if(threadIdx.x == 1 && threadIdx.y == 1)                            \
          printf("3cmpt [%02d, %02d, %02d]\n", gi, gj, gk);*/               \
         /** TODO Add your computations here */                             \
         /** TODO Store the results to global array ({...}_out)  */

#     define CAKERNEL_%{name}_Limit_Threads_To_Compute_End_s   \
      }                                                                     
#   define CAKERNEL_%{name}_Computations_End_s                 \
    }
# define CAKERNEL_%{name}_Limit_Threads_To_LSH_End_s           \
  }                                                                         
#define CAKERNEL_%{name}_Declare_End_s                         \
}


#define CAKERNEL_%{name}_Begin                                         \
CAKERNEL_%{name}_Declare_Begin_s                                       \
  CAKERNEL_%{name}_Declare_Cached_Variables_s                          \
  CAKERNEL_%{name}_Declare_Flow_Variables_s                            \
  CAKERNEL_%{name}_Limit_Threads_To_LSH_Begin_s                        \
    CAKERNEL_%{name}_Fetch_Data_To_Cache_s                             
                                                                            
#   define CAKERNEL_%{name}_Computations_Begin                         \
    CAKERNEL_%{name}_Computations_Begin_s                              \
      CAKERNEL_%{name}_Iterate_Local_Tile_s                            \
      CAKERNEL_%{name}_Fetch_Front_Tile_To_Cache_s                     \
      CAKERNEL_%{name}_Limit_Threads_To_Compute_Begin_s                
                                                                            
#   define CAKERNEL_%{name}_Computations_End                           \
      CAKERNEL_%{name}_Limit_Threads_To_Compute_End_s                  \
    CAKERNEL_%{name}_Computations_End_s                                \
  CAKERNEL_%{name}_Limit_Threads_To_LSH_End_s                   
                                                                     
#define CAKERNEL_%{name}_End                              	    	      \
CAKERNEL_%{name}_Declare_End_s




///* Declaration of the global function */
//__global__ void CAKERNEL_%{name}(                                      
///** Variables automatically added by the Cactus parser:  */                 
//%var_loop("intent=separateinout",'const CCTK_REAL *%{vname},CCTK_REAL *%{vname}_out,')
//%var_loop("intent=inout",'CCTK_REAL *%{vname},')
//%var_loop("intent=in",'const CCTK_REAL *%{vname},')
//%var_loop("intent=out",'const CCTK_REAL *%{vname},')
///** Statically added variables to each kernel: */                           
//const CaCUDA_Kernel_Launch_Parameters params);
//
//%var_loop("intent=separateinout",'extern CCTK_REAL *d_%{vname},*d_%{vname}_out;\n')
//%var_loop("intent=inout",'extern CCTK_REAL *d_%{vname};\n')
//%var_loop("intent=in",'extern CCTK_REAL *d_%{vname};\n')
//%var_loop("intent=out",'extern CCTK_REAL *d_%{vname}_out;\n')


/// !!!!!!!!!!!!!!!!!!!!!!!!! END %{name} Kernel macors !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#endif

#endif /* %{name_upper} */
